# Algorithmic Toolbox

The course covers basic algorithmic techniques and ideas for computational problems arising frequently in practical applications: sorting and searching, divide and conquer, greedy algorithms, dynamic programming. We will learn a lot of theory: how to sort data and how it helps for searching; how to break a large problem into pieces and solve them recursively; when it makes sense to proceed greedily; how dynamic programming is used in genomic studies. You will practice solving computational problems, designing new algorithms, and implementing solutions efficiently (so that they run in less than a second).

## Programming Assignments

Solve programmign assignments in one of: Python, C++, Java, C#, Javascript, C, Haskell, Ruby, Rust, Scala.

Starter solutions provided in: C++, Java, Python

## Prior Knowledge

Discrete Mathematics, specifically: proof by induction, proof by contradiction

## Course Structure

### Week 1: Programming Challenges

Welcome to the first module of Data Structures and Algorithms! Here we will provide an overview of where algorithms and data structures are used (hint: everywhere) and walk you through a few sample programming challenges. The programming challenges represent an important (and often the most difficult!) part of this specialization because the only way to fully understand an algorithm is to implement it. Writing correct and efficient programs is hard; please don’t be surprised if they don’t work as you planned—our first programs did not work either! We will help you on your journey through the specialization by showing how to implement your first programming challenges. We will also introduce testing techniques that will help increase your chances of passing assignments on your first attempt. In case your program does not work as intended, we will show how to fix it, even if you don’t yet know which test your implementation is failing on.

#### Learning Objectives

- Practice implementing algorithms
- Practice testing and stress testing programs
- Compare fast and slow programs
- Practice solving programming challenges

### Week 2: Algorithmic Warm-up

In this module you will learn that programs based on efficient algorithms can solve the same problem billions of times faster than programs based on naïve algorithms. You will learn how to estimate the running time and memory of an algorithm without even implementing it. Armed with this knowledge, you will be able to compare various algorithms, select the most efficient ones, and finally implement them as our programming challenges!


#### Learning Objectives

- Estimate the running time of an algorithm
- Practice implementing efficient solutions
- Practice solving programming challenges
- Implement programs that are several orders of magnitude faster than straightforward programs

### Week 3: Greedy Algorithms

In this module you will learn about seemingly naïve yet powerful class of algorithms called greedy algorithms. After you will learn the key idea behind the greedy algorithms, you may feel that they represent the algorithmic Swiss army knife that can be applied to solve nearly all programming challenges in this course. But be warned: with a few exceptions that we will cover, this intuitive idea rarely works in practice! For this reason, it is important to prove that a greedy algorithm always produces an optimal solution before using this algorithm. In the end of this module, we will test your intuition and taste for greedy algorithms by offering several programming challenges.

#### Learning Objectives

- Practice implementing greedy solutions
- Build greedy algorithms
- Create a program for changing money optimally
- Create a program for maximizing the value of a loot
- Create a program for maximizing the number of prize places in a competition

### Week 4: Divide-and-Conquer

In this module you will learn about a powerful algorithmic technique called Divide and Conquer. Based on this technique, you will see how to search huge databases millions of times faster than using naïve linear search. You will even learn that the standard way to multiply numbers (that you learned in the grade school) is far from the being the fastest! We will then apply the divide-and-conquer technique to design two efficient algorithms (merge sort and quick sort) for sorting huge lists, a problem that finds many applications in practice. Finally, we will show that these two algorithms are optimal, that is, no algorithm can sort faster!

#### Learning Objectives

- Express the recurrence relation on the running time of an algorithm
- Create a program for searching huge lists
- Create a program for finding a majority element
- Create a program for organizing a lottery

### Week 5: Dynamic Programming 1

In this final module of the course you will learn about the powerful algorithmic technique for solving many optimization problems called Dynamic Programming. It turned out that dynamic programming can solve many problems that evade all attempts to solve them using greedy or divide-and-conquer strategy. There are countless applications of dynamic programming in practice: from maximizing the advertisement revenue of a TV station, to search for similar Internet pages, to gene finding (the problem where biologists need to find the minimum number of mutations to transform one gene into another). You will learn how the same idea helps to automatically make spelling corrections and to show the differences between two versions of the same text.

#### Learning Objectives

- Apply dynamic programming technique to implement efficient programs
- Compute the edit distance between to files
- Practice applying the most popular algorithmic technique: dynamic programming

### Week 6: Dynamic Programming 2

In this module, we continue practicing implementing dynamic programming solutions.

#### Learning Objectives

- Continue practicing implementing dynamic programming solutions
- Learn more complex applications of dynamic programming
- Implement efficient solutions to various problems in combinatorial optimization

## Companion MOOCBook

We invite you to use the following companion book for the specialization:

[Alexander Kulikov and Pavel Pevzner. Learning Algorithms through Programming and Puzzle Solving. 2018.](http://bit.ly/moocbookc)

The book includes:

- some theory on algorithm design techniques;
- links to interactive puzzles that provide you with a fun way to invent the key algorithmic concepts yourself;
- detailed descriptions of all programming challenges in “Algorithmic Toolbox”;
- description of good programming practices that will help you to avoid many frequently made mistakes when implementing algorithms;
- detailed solutions, with Python code, of the following problems in the “Algorithmic Toolbox”: Last Digit of the Sum of Fibonacci Numbers, Collecting Signatures, Organizing a Lottery, and Maximum Amount of Gold;
- hints for many other problems.
- Order the book through [Amazon](http://bit.ly/latpa19) (printed, kindle), [Leanpub](http://bit.ly/latpl19) (pdf, mobile friendly pdf), or [MyBookOrders](http://bit.ly/latpm19) (printed). Browse sample pages (including table of contents): [printed version](http://bit.ly/2XUEVOn), [kindle version](http://bit.ly/2SvE7cL), [leanpub pdf version](http://bit.ly/2xVI3dx), [leanpub mobile friendly pdf version](https://www.dropbox.com/s/pwuwvycj38rv0ui/book_leanpub_a5_sample_pages.pdf?dl=0).
